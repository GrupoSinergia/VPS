import asyncio
import uvloop
import aiohttp
import numpy as np
import logging
from aiohttp import web
from prometheus_client import Gauge, generate_latest
from aioari import connect  # Cambio importante: usar connect en lugar de Client
from utils import get_env, setup_log
from rtp import RTPProcessor
from vad import VadController
from stt import STTWorker
from tts import TTSWorker
from llm import generate_reply
from dtmf import DTMFHandler

# Configurar uvloop
asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

class VoIPAgent:
    def __init__(self):
        self.logger = setup_log("app")
        self.ari_url = get_env("ARI_URL", "http://127.0.0.1:8088")
        self.ari_user = get_env("ARI_USER", "ari")
        self.ari_pass = get_env("ARI_PASS", "secret")
        self.ari_app = get_env("ARI_APP", "agente-ia")
        self.rtp_in_host = get_env("RTP_IN_HOST", "127.0.0.1")
        self.rtp_in_port = int(get_env("RTP_IN_PORT", 4000))
        self.rtp_out_host = get_env("RTP_OUT_HOST", "127.0.0.1")
        self.rtp_out_port = int(get_env("RTP_OUT_PORT", 4002))
        self.prometheus_port = int(get_env("PROMETHEUS_PORT", 9091))
        self.stt = STTWorker()
        self.tts = TTSWorker()
        self.rtp = RTPProcessor()
        self.vad = VadController()
        self.ari = None  # Inicializado en run
        self.dtmf = None  # Inicializado en run
        # Métricas Prometheus
        self.stt_latency = Gauge("stt_latency_seconds", "Latencia de STT")
        self.tts_latency = Gauge("tts_latency_seconds", "Latencia de TTS")
        self.llm_latency = Gauge("llm_latency_seconds", "Latencia de LLM")
        self.audio_queue = asyncio.Queue()

    async def metrics_handler(self, request):
        """Endpoint para métricas Prometheus."""
        return web.Response(body=generate_latest(), content_type="text/plain")

    async def process_audio(self, audio_data):
        """Procesar audio a través del pipeline STT -> LLM -> TTS."""
        start_time = asyncio.get_event_loop().time()
        transcription = await self.stt.process_audio(audio_data)
        self.stt_latency.set(asyncio.get_event_loop().time() - start_time)
        if not transcription:
            return
        text = " ".join(transcription)
        self.logger.info(f"Transcripción: {text}")
        start_time = asyncio.get_event_loop().time()
        prompt = get_env("LLM_PROMPT", "") + "\nUsuario: " + text
        reply = generate_reply(prompt)
        self.llm_latency.set(asyncio.get_event_loop().time() - start_time)
        self.logger.info(f"Respuesta LLM: {reply}")
        start_time = asyncio.get_event_loop().time()
        rate, audio = self.tts.synthesize(reply)
        self.tts_latency.set(asyncio.get_event_loop().time() - start_time)
        encoded_audio = self.rtp.encode(audio)
        self.logger.info("Audio enviado al RTP")

    async def on_channel(self, *args, **kwargs):
        """Manejar evento StasisStart - VERSIÓN FINAL."""
        try:
            if len(args) > 0:
                event = args[0]
                self.logger.info(f"Evento StasisStart recibido para canal: {event.get('channel', {}).get('name', 'unknown')}")
                
                # Extraer información del canal
                channel_info = event['channel']
                channel_id = channel_info['id']
                channel_name = channel_info['name']
                caller_number = channel_info.get('caller', {}).get('number', 'unknown')
                
                self.logger.info(f"Procesando llamada de {caller_number} en canal {channel_name}")
                
                # Obtener objeto canal y responder
                channel_obj = await self.ari.channels.get(channelId=channel_id)
                await channel_obj.answer()
                self.logger.info(f"Llamada respondida exitosamente")
                
                # Reproducir mensaje de bienvenida
                await self.play_welcome_message(channel_obj)
                
                # Iniciar procesamiento de audio bidireccional
                await self.start_audio_processing(channel_obj)
                
            else:
                self.logger.error("No se recibieron argumentos en on_channel")
                
        except Exception as e:
            self.logger.error(f"Error en on_channel: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")

    async def play_welcome_message(self, channel):
        """Reproducir mensaje de bienvenida."""
        try:
            self.logger.info("Reproduciendo mensaje de bienvenida")
            welcome_text = "Hola, soy tu asistente virtual. ¿En qué puedo ayudarte hoy?"
            
            # Sintetizar mensaje de bienvenida - CORREGIDO sin speaker_id
            try:
                rate, audio_data = self.tts.synthesize(welcome_text)
                self.logger.info("TTS completado exitosamente")
            except Exception as tts_error:
                self.logger.error(f"Error en TTS: {tts_error}")
                # Si TTS falla, usar un beep simple
                await self.play_simple_tone(channel)
                return
            
            # Crear archivo temporal de audio
            import tempfile
            import wave
            
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as tmp_file:
                # Convertir audio a formato WAV
                with wave.open(tmp_file.name, 'wb') as wav_file:
                    wav_file.setnchannels(1)  # Mono
                    wav_file.setsampwidth(2)  # 16-bit
                    wav_file.setframerate(rate)
                    
                    # Convertir float32 a int16
                    audio_int16 = (audio_data * 32767).astype(np.int16)
                    wav_file.writeframes(audio_int16.tobytes())
                
                # Reproducir en el canal - CORREGIDO el parámetro
                try:
                    playback = await channel.play(media=f"file:{tmp_file.name}")
                    self.logger.info("Mensaje de bienvenida enviado al canal")
                except Exception as play_error:
                    self.logger.error(f"Error reproduciendo audio: {play_error}")
                    # Alternativa: usar un tono simple
                    await self.play_simple_tone(channel)
                
                # Limpiar archivo temporal después de un tiempo
                asyncio.create_task(self.cleanup_temp_file(tmp_file.name, 30))
                
        except Exception as e:
            self.logger.error(f"Error reproduciendo mensaje de bienvenida: {e}")

    async def play_simple_tone(self, channel):
        """Reproducir un tono simple como alternativa."""
        try:
            # Usar un tono predefinido de Asterisk
            playback = await channel.play(media="sound:beep")
            self.logger.info("Tono simple reproducido")
        except Exception as e:
            self.logger.error(f"Error reproduciendo tono simple: {e}")
            try:
                # Última alternativa: usar ring
                playback = await channel.ring()
                await asyncio.sleep(2)
                await channel.ringStop()
                self.logger.info("Ring enviado como audio de prueba")
            except Exception as ring_error:
                self.logger.error(f"Error con ring: {ring_error}")

    async def cleanup_temp_file(self, filepath, delay_seconds):
        """Limpiar archivo temporal después de un retraso."""
        try:
            await asyncio.sleep(delay_seconds)
            import os
            if os.path.exists(filepath):
                os.unlink(filepath)
                self.logger.info(f"Archivo temporal limpiado: {filepath}")
        except Exception as e:
            self.logger.error(f"Error limpiando archivo temporal: {e}")

    async def start_audio_processing(self, channel):
        """Iniciar procesamiento de audio bidireccional."""
        try:
            self.logger.info(f"Iniciando procesamiento de audio para canal {channel.id}")
            
            # Reproducir audio de prueba usando archivos predefinidos de Asterisk
            try:
                self.logger.info("Reproduciendo audio de prueba con archivos de Asterisk")
                # Reproducir mensaje usando archivos de sistema de Asterisk
                playback = await channel.play(media="sound:hello-world")
                self.logger.info("Audio de prueba 'hello-world' enviado")
                
                await asyncio.sleep(3)  # Esperar a que termine
                
                # Segundo intento con otro archivo
                playback2 = await channel.play(media="sound:demo-congrats")
                self.logger.info("Audio de prueba 'demo-congrats' enviado")
                
            except Exception as audio_error:
                self.logger.error(f"Error con archivos de audio: {audio_error}")
                # Fallback: usar silence
                try:
                    playback = await channel.play(media="sound:silence/5")
                    self.logger.info("Reproduciendo 5 segundos de silencio como prueba")
                except Exception as silence_error:
                    self.logger.error(f"Error incluso con silence: {silence_error}")
            
            # Configurar detección DTMF mejorada
            def on_dtmf(channel_obj, event):
                digit = event.get('digit', '?')
                self.logger.info(f"DTMF recibido: {digit}")
                # Responder al DTMF con un eco
                asyncio.create_task(self.respond_to_dtmf(channel, digit))
                
            # Registrar handler para DTMF en este canal específico
            channel.on_event('ChannelDtmfReceived', on_dtmf)
            
            # Mantener el canal activo
            await self.audio_queue.put(channel)
            
            self.logger.info("Procesamiento de audio iniciado - Canal listo para recibir entrada")
            
        except Exception as e:
            self.logger.error(f"Error iniciando procesamiento de audio: {e}")

    async def respond_to_dtmf(self, channel, digit):
        """Responder a DTMF con audio."""
        try:
            self.logger.info(f"Respondiendo a DTMF: {digit}")
            # Usar archivos de dígitos predefinidos de Asterisk
            playback = await channel.play(media=f"sound:digits/{digit}")
            self.logger.info(f"Reprodujo eco del dígito: {digit}")
        except Exception as e:
            self.logger.error(f"Error respondiendo a DTMF {digit}: {e}")
            try:
                # Fallback: usar beep
                playback = await channel.play(media="sound:beep")
                self.logger.info("Reprodujo beep como respuesta a DTMF")
            except Exception as beep_error:
                self.logger.error(f"Error con beep: {beep_error}")

    async def connect_ari(self):
        """Conectar a ARI de forma segura."""
        max_retries = 3
        retry_delay = 5

        for attempt in range(max_retries):
            try:
                self.logger.info(f"Intentando conectar a ARI (intento {attempt + 1}/{max_retries})")

                # Usar connect en lugar de Client para evitar RecursionError
                self.ari = await connect(
                    base_url=self.ari_url,
                    username=self.ari_user,
                    password=self.ari_pass
                )

                # Verificar conexión obteniendo info de Asterisk
                asterisk_info = await self.ari.asterisk.getInfo()
                self.logger.info(f"Conectado a Asterisk: {asterisk_info['build']['date']}")

                # Configurar manejadores de eventos
                self.ari.on_event('StasisStart', self.on_channel)

                # CORRECCIÓN CRÍTICA: Iniciar el procesamiento WebSocket
                self.logger.info(f"Preparado para recibir eventos de: {self.ari_app}")
                self.logger.info("Iniciando procesamiento WebSocket...")

                # Inicializar DTMF handler
                self.dtmf = DTMFHandler(self.ari)

                self.logger.info("Conexión ARI exitosa")
                return True

            except Exception as e:
                self.logger.error(f"Error en intento {attempt + 1}: {e}")
                if attempt < max_retries - 1:
                    self.logger.info(f"Reintentando en {retry_delay} segundos...")
                    await asyncio.sleep(retry_delay)
                    retry_delay *= 2  # Backoff exponencial
                else:
                    self.logger.error("No se pudo conectar a ARI después de todos los intentos")
                    return False

    async def run(self):
        """Iniciar el agente VoIP."""
        self.logger.info("Iniciando VoIP Agent")

        # Configurar servidor de métricas
        app = web.Application()
        app.add_routes([web.get("/metrics", self.metrics_handler)])
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, "0.0.0.0", self.prometheus_port)
        await site.start()
        self.logger.info(f"Servidor de métricas iniciado en puerto {self.prometheus_port}")

        # Conectar con ARI
        try:
            if not await self.connect_ari():
                raise Exception("No se pudo conectar a ARI")
        except Exception as e:
            self.logger.error(f"Error conectando a ARI: {e}")
            raise

        # CORRECCIÓN CRÍTICA: Ejecutar el procesamiento WebSocket con apps
        try:
            self.logger.info("Iniciando procesamiento de audio y WebSocket...")

            # Crear tareas para ejecutar en paralelo
            # CORRECCIÓN PRINCIPAL: agregar apps=[self.ari_app]
            websocket_task = asyncio.create_task(self.ari.run(apps=[self.ari_app]))
            audio_task = asyncio.create_task(self.process_audio_loop())

            # Esperar que cualquiera de las tareas termine
            await asyncio.gather(websocket_task, audio_task)

        except KeyboardInterrupt:
            self.logger.info("Deteniendo VoIP Agent...")
        except Exception as e:
            self.logger.error(f"Error fatal: {e}")
            raise
        finally:
            # Limpiar recursos
            if self.ari:
                try:
                    await self.ari.close()
                except:
                    pass

    async def process_audio_loop(self):
        """Loop para procesar canales activos."""
        while True:
            try:
                # Esperar por canales entrantes
                channel = await asyncio.wait_for(self.audio_queue.get(), timeout=1.0)
                self.logger.info(f"Canal activo en cola: {channel.id}")
                
                # El canal ya está siendo procesado en start_audio_processing
                # Este loop mantiene el estado del canal activo
                
                # En una implementación completa, aquí se procesaría:
                # 1. Audio RTP entrante (STT)
                # 2. Generación de respuestas (LLM) 
                # 3. Audio RTP saliente (TTS)
                
            except asyncio.TimeoutError:
                # Continuar el bucle si no hay canales
                continue
            except Exception as e:
                self.logger.error(f"Error en process_audio_loop: {e}")

async def main():
    agent = VoIPAgent()
    try:
        await agent.run()
    except Exception as e:
        logging.getLogger("app").error(f"Error fatal: {e}")
        raise

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nVoIP Agent detenido por el usuario")
    except Exception as e:
        print(f"Error: {e}")
        exit(1)
