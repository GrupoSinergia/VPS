import logging
import asyncio
import json
import websockets
import aiohttp
from config import ARI_URL, ARI_USERNAME, ARI_PASSWORD
from stt import STTWorker
from tts import TTSWorker
from rtp import RTPProcessor

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ModernARIClient:
    def __init__(self, base_url, username, password):
        self.base_url = "http://localhost:8088"  # URL fija que funciona
        self.username = username
        self.password = password
        self.ws_url = f"ws://localhost:8088/ari/events?api_key={username}:{password}&app=agente-ia&subscribeAll=true"
        self.websocket = None
        
    async def connect(self):
        """Conectar al WebSocket de ARI"""
        try:
            # Registrar aplicación
            await self.register_app()
            # Conectar WebSocket
            self.websocket = await websockets.connect(self.ws_url)
            logger.info("Conectado a ARI exitosamente.")
            return self.websocket
        except Exception as e:
            logger.error(f"Error conectando a ARI: {e}")
            raise
    
    async def register_app(self):
        """Registrar aplicación Stasis"""
        url = "http://localhost:8088/ari/applications/agente-ia"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, auth=aiohttp.BasicAuth(self.username, self.password)) as response:
                    if response.status in [200, 409]:
                        logger.info("Registrando la aplicación Stasis 'agente-ia'...")
                    else:
                        logger.error(f"Error registrando app: {response.status}")
        except Exception as e:
            logger.error(f"Error en registro: {e}")

    async def answer_channel(self, channel_id):
        """Responder canal"""
        url = f"http://localhost:8088/ari/channels/{channel_id}/answer"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, auth=aiohttp.BasicAuth(self.username, self.password)) as response:
                    if response.status == 204:
                        logger.info(f"Canal {channel_id} respondido.")
                    else:
                        logger.error(f"Error respondiendo canal: {response.status}")
        except Exception as e:
            logger.error(f"Error respondiendo: {e}")

    async def play_media(self, channel_id, media):
        """Reproducir media"""
        url = f"http://localhost:8088/ari/channels/{channel_id}/play"
        data = {"media": media}
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data, auth=aiohttp.BasicAuth(self.username, self.password)) as response:
                    if response.status == 201:
                        logger.info("Saludo reproducido.")
                    else:
                        logger.error(f"Error reproduciendo: {response.status}")
        except Exception as e:
            logger.error(f"Error en play: {e}")

    async def hangup_channel(self, channel_id):
        """Colgar canal"""
        url = f"http://localhost:8088/ari/channels/{channel_id}"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.delete(url, auth=aiohttp.BasicAuth(self.username, self.password)) as response:
                    if response.status == 204:
                        logger.info(f"Colgando el canal {channel_id}")
                    else:
                        logger.error(f"Error colgando: {response.status}")
        except Exception as e:
            logger.error(f"Error colgando: {e}")

async def on_stasis_start(client, event):
    """
    Manejador para el evento StasisStart - MANTIENE TU ESTRUCTURA ORIGINAL
    """
    try:
        channel = event.get('channel', {})
        channel_id = channel.get('id')
        channel_name = channel.get('name', 'Unknown')
        
        logger.info(f"Llamada entrando en Stasis: {channel_name}")
        
        # 1. Responder la llamada
        await client.answer_channel(channel_id)
        
        # 2. Reproducir un saludo inicial (ejemplo)
        # Aquí es donde integrarías tu lógica de TTS
        await client.play_media(channel_id, 'sound:hello-world')
        
        # 3. Aquí comenzaría la lógica de la conversación
        # (STT -> LLM -> TTS) en un bucle.
        # Por ahora, simplemente colgamos después de 5 segundos.
        await asyncio.sleep(5)
        
        # 4. Colgar la llamada
        await client.hangup_channel(channel_id)
        
    except Exception as e:
        logger.error(f"Error en on_stasis_start: {e}")

async def main():
    """
    Función principal - MANTIENE TU ESTRUCTURA ORIGINAL
    """
    try:
        # Crear cliente ARI moderno
        client = ModernARIClient(ARI_URL, ARI_USERNAME, ARI_PASSWORD)
        
        # Conectar
        websocket = await client.connect()
        logger.info("Suscripción exitosa. Esperando llamadas...")
        
        # Escuchar eventos (como tu código original)
        async for message in websocket:
            try:
                event = json.loads(message)
                event_type = event.get('type')
                
                if event_type == 'StasisStart':
                    # Procesar como tu código original
                    asyncio.create_task(on_stasis_start(client, event))
                    
            except json.JSONDecodeError:
                logger.error("Error decodificando JSON")
            except Exception as e:
                logger.error(f"Error procesando evento: {e}")
                
    except KeyboardInterrupt:
        logger.info("Cerrando la conexión con ARI.")
    except Exception as e:
        logger.error(f"Error en main: {e}")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nAgente detenido por el usuario.")
