import os
import numpy as np
from piper import PiperVoice
from utils import resample_48k_to_8k, get_env, setup_log

class TTSWorker:
    def __init__(self):
        self.logger = setup_log(__name__)
        self.voice = '/root/.cache/piper/es_MX-claude-high.onnx'
        self.rate = float(get_env('PIPER_RATE', '1.0'))
        try:
            self.model = PiperVoice.load(self.voice)
            self.logger.info(f"Loaded Piper voice: {self.voice}")
        except Exception as e:
            self.logger.error(f"Failed to load Piper voice {self.voice}: {e}")
            raise

    def synthesize(self, text):
        """Synthesize text to audio using Piper TTS."""
        try:
            self.logger.info(f"Iniciando síntesis TTS para: {text[:50]}...")
            
            # Piper devuelve un generador de AudioChunk objects
            audio_generator = self.model.synthesize(text)
            
            # Recolectar chunks válidos y extraer audio
            audio_chunks = []
            total_samples = 0
            
            for i, chunk in enumerate(audio_generator):
                self.logger.info(f"Procesando chunk {i}: {type(chunk)}")
                
                # Extraer audio usando el atributo correcto descubierto
                audio_data = None
                
                try:
                    # SOLUCIÓN: Usar audio_int16_array que contiene el audio real
                    if hasattr(chunk, 'audio_int16_array'):
                        audio_data = chunk.audio_int16_array
                        self.logger.info(f"ÉXITO: Extraído {len(audio_data)} samples de audio_int16_array")
                    elif hasattr(chunk, 'audio_float_array'):
                        # Alternativa: usar audio_float_array y convertir
                        float_audio = chunk.audio_float_array
                        audio_data = (float_audio * 32767).astype(np.int16)
                        self.logger.info(f"ÉXITO: Convertido {len(audio_data)} samples de audio_float_array")
                    else:
                        self.logger.error(f"Chunk {i} no tiene audio_int16_array ni audio_float_array")
                        continue
                    
                    # Verificar que el audio sea válido
                    if isinstance(audio_data, np.ndarray) and audio_data.size > 0:
                        audio_chunks.append(audio_data)
                        total_samples += len(audio_data)
                        self.logger.info(f"Chunk {i} agregado: {len(audio_data)} samples")
                    else:
                        self.logger.error(f"Chunk {i} audio inválido: {type(audio_data)}")
                        
                except Exception as chunk_error:
                    self.logger.error(f"Error extrayendo chunk {i}: {chunk_error}")
            
            self.logger.info(f"=== RESUMEN EXTRACCIÓN ===")
            self.logger.info(f"Chunks procesados: {len(audio_chunks)}")
            self.logger.info(f"Total samples: {total_samples}")
            
            if not audio_chunks:
                self.logger.error("No se extrajo audio válido")
                return self._generate_fallback_tone()
            
            # Concatenar chunks válidos
            if len(audio_chunks) == 1:
                audio = audio_chunks[0]
            else:
                try:
                    audio = np.concatenate(audio_chunks)
                    self.logger.info(f"Audio concatenado: {len(audio)} samples")
                except ValueError as concat_error:
                    self.logger.error(f"Error concatenando: {concat_error}")
                    audio = audio_chunks[0]
            
            # Verificar resultado final
            self.logger.info(f"Audio final: {len(audio)} samples, dtype: {audio.dtype}")
            
            if len(audio) == 0:
                return self._generate_fallback_tone()
            
            # El audio ya está en int16, pero verificar rango
            if audio.dtype == np.int16:
                audio_final = audio
            else:
                # Convertir a int16 si es necesario
                if audio.dtype in [np.float32, np.float64]:
                    audio = np.clip(audio, -1.0, 1.0)
                    audio_final = (audio * 32767).astype(np.int16)
                else:
                    audio_final = audio.astype(np.int16)
            
            # Resample de 22050Hz a 8000Hz para telefonía
            try:
                # Convertir a float para resample
                audio_float = audio_final.astype(np.float32) / 32767.0
                audio_resampled = resample_48k_to_8k(audio_float, orig_sr=22050, target_sr=8000)
                audio_8k = (audio_resampled * 32767).astype(np.int16)
                
                self.logger.info(f"Resample exitoso: {len(audio_final)} -> {len(audio_8k)} samples")
                return 8000, audio_8k
                
            except Exception as resample_error:
                self.logger.error(f"Error en resample: {resample_error}")
                # Usar audio original a 22050Hz
                self.logger.info(f"Usando audio original a 22050Hz: {len(audio_final)} samples")
                return 22050, audio_final
            
        except Exception as e:
            self.logger.error(f"TTS synthesis failed: {e}")
            import traceback
            self.logger.error(f"Traceback: {traceback.format_exc()}")
            return self._generate_fallback_tone()
    
    def _generate_fallback_tone(self):
        """Generar un tono simple como fallback cuando TTS falla."""
        try:
            # Crear un tono simple de 1 segundo a 8kHz
            duration = 1.0
            sample_rate = 8000
            t = np.linspace(0, duration, int(sample_rate * duration), False)
            frequency = 440  # La nota A
            audio_fallback = np.sin(2 * np.pi * frequency * t) * 0.3
            audio_fallback_int16 = (audio_fallback * 32767).astype(np.int16)
            
            self.logger.info("Generado audio fallback: tono de 440Hz")
            return sample_rate, audio_fallback_int16
            
        except Exception as fallback_error:
            self.logger.error(f"Error generando fallback: {fallback_error}")
            return 8000, np.array([], dtype=np.int16)
